import { supabase } from "@/integrations/supabase/client";
import { Database } from "@/integrations/supabase/types";
import { MilestoneService } from "./milestoneService";

type Invoice = Database["public"]["Tables"]["invoices"]["Row"];
type InvoiceInsert = Database["public"]["Tables"]["invoices"]["Insert"];
type InvoiceUpdate = Database["public"]["Tables"]["invoices"]["Update"];
type InvoiceItem = Database["public"]["Tables"]["invoice_items"]["Row"];
type InvoiceItemInsert =
  Database["public"]["Tables"]["invoice_items"]["Insert"];

export interface InvoiceWithItems extends Invoice {
  invoice_items?: InvoiceItem[];
  milestones?: {
    name: string;
    projects?: {
      name: string;
      site_location: string | null;
    };
  };
}

export interface ClientDetails {
  client_name: string;
  client_email?: string;
  client_address?: string;
}

export class InvoiceService {
  /**
   * Generate invoice from milestone data
   */
  static async generateInvoice(
    milestoneId: string,
    clientDetails: ClientDetails
  ): Promise<Invoice> {
    // Check if milestone can generate invoice
    const canGenerate = await MilestoneService.canGenerateInvoice(milestoneId);
    if (!canGenerate.can_generate) {
      throw new Error(canGenerate.reason || "Cannot generate invoice");
    }

    // Calculate invoice amount
    const amount = await this.calculateInvoiceAmount(milestoneId);

    // Get current user
    const {
      data: { user },
    } = await supabase.auth.getUser();

    // Create invoice
    const invoiceData: InvoiceInsert = {
      milestone_id: milestoneId,
      invoice_number: "", // Will be auto-generated by trigger
      issue_date: new Date().toISOString().split("T")[0],
      due_date: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)
        .toISOString()
        .split("T")[0], // 30 days from now
      status: "draft",
      subtotal: amount.subtotal,
      tax_rate: 0,
      tax_amount: 0,
      total: amount.total,
      balance_due: amount.total,
      client_name: clientDetails.client_name,
      client_email: clientDetails.client_email || null,
      client_address: clientDetails.client_address || null,
      created_by: user?.id,
    };

    const { data: invoice, error } = await supabase
      .from("invoices")
      .insert(invoiceData)
      .select()
      .single();

    if (error) throw error;

    // Create invoice items
    await this.createInvoiceItems(invoice.id, milestoneId, amount.items);

    return invoice;
  }

  /**
   * Calculate invoice amount from milestone data
   */
  static async calculateInvoiceAmount(milestoneId: string): Promise<{
    subtotal: number;
    total: number;
    items: Array<{
      description: string;
      quantity: number;
      rate: number;
      amount: number;
      item_type: string;
    }>;
  }> {
    const items: Array<{
      description: string;
      quantity: number;
      rate: number;
      amount: number;
      item_type: string;
    }> = [];

    // Get wage summary
    const wageSummary = await MilestoneService.getMilestoneWageSummary(
      milestoneId
    );

    if (wageSummary.total_wages > 0) {
      items.push({
        description: "Labor & Wages",
        quantity: 1,
        rate: wageSummary.total_wages,
        amount: wageSummary.total_wages,
        item_type: "wage",
      });
    }

    // Get expenses
    const { data: expenses } = await supabase
      .from("project_expenses")
      .select("*")
      .eq("milestone_id", milestoneId);

    if (expenses) {
      for (const expense of expenses) {
        items.push({
          description: `${expense.expense_category}: ${expense.description}`,
          quantity: 1,
          rate: Number(expense.amount),
          amount: Number(expense.amount),
          item_type: "expense",
        });
      }
    }

    const subtotal = items.reduce((sum, item) => sum + item.amount, 0);

    return {
      subtotal,
      total: subtotal,
      items,
    };
  }

  /**
   * Create invoice items
   */
  private static async createInvoiceItems(
    invoiceId: string,
    milestoneId: string,
    items: Array<{
      description: string;
      quantity: number;
      rate: number;
      amount: number;
      item_type: string;
    }>
  ): Promise<void> {
    const invoiceItems: InvoiceItemInsert[] = items.map((item) => ({
      invoice_id: invoiceId,
      description: item.description,
      quantity: item.quantity,
      rate: item.rate,
      amount: item.amount,
      item_type: item.item_type as "wage" | "expense" | "custom",
      reference_type: "none",
    }));

    const { error } = await supabase.from("invoice_items").insert(invoiceItems);

    if (error) throw error;
  }

  /**
   * Create a custom invoice
   */
  static async createInvoice(invoiceData: InvoiceInsert): Promise<Invoice> {
    const { data, error } = await supabase
      .from("invoices")
      .insert(invoiceData)
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  /**
   * Create a custom invoice with items in a transaction
   */
  static async createInvoiceWithItems(
    invoiceData: InvoiceInsert,
    items: Array<{
      description: string;
      quantity: number;
      rate: number;
      amount: number;
      item_type: "wage" | "expense" | "custom";
    }>
  ): Promise<InvoiceWithItems> {
    // Start a transaction by creating the invoice first
    const { data: invoice, error: invoiceError } = await supabase
      .from("invoices")
      .insert(invoiceData)
      .select()
      .single();

    if (invoiceError) throw invoiceError;

    // Create invoice items
    const invoiceItems: InvoiceItemInsert[] = items.map((item) => ({
      invoice_id: invoice.id,
      description: item.description,
      quantity: item.quantity,
      rate: item.rate,
      amount: item.amount,
      item_type: item.item_type,
      reference_type: "none",
    }));

    const { error: itemsError } = await supabase
      .from("invoice_items")
      .insert(invoiceItems);

    if (itemsError) {
      // If items creation fails, try to clean up the invoice
      await supabase.from("invoices").delete().eq("id", invoice.id);
      throw itemsError;
    }

    // Return the complete invoice with items
    return this.getInvoiceById(invoice.id);
  }

  /**
   * Update an invoice
   */
  static async updateInvoice(
    invoiceId: string,
    updates: InvoiceUpdate
  ): Promise<Invoice> {
    const { data, error } = await supabase
      .from("invoices")
      .update(updates)
      .eq("id", invoiceId)
      .select()
      .single();

    if (error) throw error;
    return data;
  }

  /**
   * Get invoice by ID with items
   */
  static async getInvoiceById(invoiceId: string): Promise<InvoiceWithItems> {
    const { data, error } = await supabase
      .from("invoices")
      .select(
        `
        *,
        invoice_items (*),
        milestones (
          name,
          project_id,
          projects (
            id,
            name,
            site_location,
            currency
          )
        )
      `
      )
      .eq("id", invoiceId)
      .single();

    if (error) throw error;
    return data as InvoiceWithItems;
  }

  /**
   * Get invoice by share token (public access)
   */
  static async getInvoiceByToken(
    shareToken: string
  ): Promise<InvoiceWithItems> {
    const { data, error } = await supabase
      .from("invoices")
      .select(
        `
        *,
        invoice_items (*),
        milestones (
          name,
          projects (
            name,
            site_location,
            currency
          )
        )
      `
      )
      .eq("share_token", shareToken)
      .single();

    if (error) throw error;
    return data as InvoiceWithItems;
  }

  /**
   * Generate share token for an invoice
   */
  static async generateShareToken(invoiceId: string): Promise<string> {
    // Get current invoice to check if it has a share token
    const { data: invoice } = await supabase
      .from("invoices")
      .select("share_token")
      .eq("id", invoiceId)
      .single();

    // If share token exists, return it
    if (invoice?.share_token) {
      return invoice.share_token;
    }

    // Generate new token (UUID is auto-generated by default in database)
    const { data, error } = await supabase
      .from("invoices")
      .update({ share_token: crypto.randomUUID() })
      .eq("id", invoiceId)
      .select("share_token")
      .single();

    if (error) throw error;
    return data.share_token!;
  }

  /**
   * Update invoice status
   */
  static async updateInvoiceStatus(
    invoiceId: string,
    status: Invoice["status"]
  ): Promise<void> {
    const { error } = await supabase
      .from("invoices")
      .update({ status })
      .eq("id", invoiceId);

    if (error) throw error;
  }

  /**
   * Get invoices by project
   */
  static async getInvoicesByProject(projectId: string): Promise<Invoice[]> {
    // Get milestones for the project
    const { data: milestones } = await supabase
      .from("milestones")
      .select("id")
      .eq("project_id", projectId);

    if (!milestones || milestones.length === 0) {
      return [];
    }

    const milestoneIds = milestones.map((m) => m.id);

    const { data, error } = await supabase
      .from("invoices")
      .select("*")
      .in("milestone_id", milestoneIds)
      .order("created_at", { ascending: false });

    if (error) throw error;
    return data;
  }

  /**
   * Get invoices by milestone
   */
  static async getInvoicesByMilestone(milestoneId: string): Promise<Invoice[]> {
    const { data, error } = await supabase
      .from("invoices")
      .select("*")
      .eq("milestone_id", milestoneId)
      .order("created_at", { ascending: false });

    if (error) throw error;
    return data;
  }

  /**
   * Delete an invoice
   */
  static async deleteInvoice(invoiceId: string): Promise<void> {
    const { error } = await supabase
      .from("invoices")
      .delete()
      .eq("id", invoiceId);

    if (error) throw error;
  }

  /**
   * Get all invoices with filters
   */
  static async getAllInvoices(filters?: {
    status?: string;
    projectId?: string;
  }): Promise<InvoiceWithItems[]> {
    let query = supabase
      .from("invoices")
      .select(
        `
        *,
        invoice_items (*),
        milestones (
          name,
          project_id,
          projects (
            name,
            site_location,
            currency
          )
        )
      `
      )
      .order("created_at", { ascending: false });

    if (filters?.status) {
      query = query.eq("status", filters.status);
    }

    const { data, error } = await query;

    if (error) throw error;

    // Filter by project if needed
    let result = data as InvoiceWithItems[];
    if (filters?.projectId) {
      result = result.filter(
        (inv) => inv.milestones?.projects?.id === filters.projectId
      );
    }

    return result;
  }

  /**
   * Add custom item to invoice
   */
  static async addInvoiceItem(
    invoiceId: string,
    item: InvoiceItemInsert
  ): Promise<InvoiceItem> {
    const { data, error } = await supabase
      .from("invoice_items")
      .insert({ ...item, invoice_id: invoiceId })
      .select()
      .single();

    if (error) throw error;

    // Recalculate invoice totals
    await this.recalculateInvoiceTotals(invoiceId);

    return data;
  }

  /**
   * Delete invoice item
   */
  static async deleteInvoiceItem(itemId: string): Promise<void> {
    // Get the invoice ID first
    const { data: item } = await supabase
      .from("invoice_items")
      .select("invoice_id")
      .eq("id", itemId)
      .single();

    const { error } = await supabase
      .from("invoice_items")
      .delete()
      .eq("id", itemId);

    if (error) throw error;

    // Recalculate invoice totals
    if (item) {
      await this.recalculateInvoiceTotals(item.invoice_id);
    }
  }

  /**
   * Recalculate invoice totals
   */
  private static async recalculateInvoiceTotals(
    invoiceId: string
  ): Promise<void> {
    // Get all items for this invoice
    const { data: items } = await supabase
      .from("invoice_items")
      .select("amount")
      .eq("invoice_id", invoiceId);

    const subtotal =
      items?.reduce((sum, item) => sum + Number(item.amount), 0) || 0;

    // Get current invoice to preserve tax rate
    const { data: invoice } = await supabase
      .from("invoices")
      .select("tax_rate, amount_paid")
      .eq("id", invoiceId)
      .single();

    const taxRate = Number(invoice?.tax_rate) || 0;
    const taxAmount = subtotal * (taxRate / 100);
    const total = subtotal + taxAmount;
    const amountPaid = Number(invoice?.amount_paid) || 0;
    const balanceDue = total - amountPaid;

    // Update invoice
    const { error } = await supabase
      .from("invoices")
      .update({
        subtotal,
        tax_amount: taxAmount,
        total,
        balance_due: balanceDue,
      })
      .eq("id", invoiceId);

    if (error) throw error;
  }
}
